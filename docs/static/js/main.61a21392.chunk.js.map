{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","categories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","id","title","images","downsized_medium","console","log","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","img","setTimeout","useFetchGifs","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"mMAIaA,EAAc,SAAC,GAAiC,IAAhCC,EAA+B,EAA/BA,cAAeC,EAAgB,EAAhBA,WAAgB,EAEpBC,mBAAS,IAFW,mBAEjDC,EAFiD,KAErCC,EAFqC,KAwBxD,OAGI,aADI,CACJ,QAAMC,SAlBW,SAACC,GAElBA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,IAI3BT,EAAc,CAACG,GAAF,mBAAiBF,KAE9BG,EAAc,MAQlB,SAEI,uBAAOM,KAAK,OAAOC,MAAOR,EAAYS,SAzBpB,SAACN,GAEvBF,EAAcE,EAAEO,OAAOF,a,+BCTlBG,EAAO,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DAIbC,EAJa,gDAIkCC,UAAUH,GAJ5C,+DAMAI,MAAMF,GANN,cAMbG,EANa,gBAQEA,EAAKC,OARP,uBAQZC,EARY,EAQZA,KAEDC,EAAOD,EAAKE,KAAI,YAA0B,IAAxBC,EAAuB,EAAvBA,GAAIC,EAAmB,EAAnBA,MAAOC,EAAY,EAAZA,OAC/B,MAAO,CAEHF,GAAIA,EACJC,MAAOA,EAEPT,IAAG,OAAEU,QAAF,IAAEA,OAAF,EAAEA,EAAQC,iBAAiBX,QAItCY,QAAQC,IAAI,wBAA0BP,GAEtCM,QAAQC,IAAIP,GAtBO,kBAuBZA,GAvBY,4CAAH,sDCEPQ,EAAc,SAAC,GAAoB,IAAlBL,EAAiB,EAAjBA,MAAOT,EAAU,EAAVA,IAEjC,OACI,sBAAKe,UAAU,6CAAf,UAEI,qBAAKC,IAAKhB,EAAKiB,IAAKR,IACpB,4BAAIA,QCJHS,EAAU,SAAC,GAAgB,IAAfpB,EAAc,EAAdA,SAAc,ECAX,SAACA,GAAc,IAAD,EAEZb,mBAAS,CAC/ByB,OAAQ,GACRS,SAAS,IAJyB,mBAE/BC,EAF+B,KAExBC,EAFwB,KA+BtC,OAnBAC,qBAAU,WAENzB,EAAQC,GAAUyB,MAAK,SAAAC,GAGnBC,YAAW,WAEPJ,EAAS,CACLX,OAAQc,EACRL,SAAS,MAGd,UAKR,CAACrB,IAEGsB,ED5BmBM,CAAa5B,GAAhCY,EAH4B,EAG5BA,OAAQS,EAHoB,EAGpBA,QAEf,OACI,0CACI,oBAAIJ,UAAU,wCAAd,SAAuDjB,IAEvD,oBAAIiB,UAAU,mCAAd,SAAkDI,GAAW,gBAE7D,qBAAKJ,UAAU,YAAf,SAIQL,EAAOH,KAAK,SAAAG,GACR,OAAO,cAAC,EAAD,eAGEA,GAFAA,EAAOF,aEkBzBmB,EAlCM,WAAM,MAGa1C,mBAAS,IAHtB,mBAGhBD,EAHgB,KAGJD,EAHI,KAMvB,OACI,qCACI,8CAKA,cAAC,EAAD,CAAaA,cAAeA,EAAeC,WAAYA,IACvD,uBAEA,6BAGQA,EAAWuB,KAAK,SAAAT,GACZ,OAAO,cAAC,EAAD,CAIHA,SAAUA,GAFLA,Y,MCvBjC8B,IAASC,OAEL,cAAC,EAAD,IAAiBC,SAASC,eAAe,W","file":"static/js/main.61a21392.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\n// Usar props\r\nexport const AddCategory = ({setCategories, categories}) => {\r\n\r\n    const [inputValue, setInputValue] = useState(''); // Hay que colocar un string vacio, porque si no lo colocamos nos marcaria un error en consola\r\n\r\n    const handleInputChange = (e) => {\r\n        // Permite ver que se esta cambiando el estado de nuestro InputValue gracias a que estamos registrandole el nuevo estado gracias al e (que es el evento que en este caso es onChange).target(Apunta al input).value(el valor/lo que estamos tecleando en el), y con esto se esta retroalimentando el solo, cada tecla es un nuevo cambio de estado\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n        // Prevenimos el clasico refresh\r\n        e.preventDefault();\r\n        // Con .trim limpiamos espacios en blanco y damos lectura a que por lo menos el String tenga 2 caracteres\r\n        if( inputValue.trim().length > 2 ){\r\n            // Cambiamos el estado del listado de animes del componente padre\r\n            // ...Y aqui colocar cat => [...cat, inputValue], porque yo si no pasara como prop las categories no las tendria como referencia, pero solamente al hacer la referencia al setCategories, que tiene el estado anterior y voy a hacer el a√±adido aca(inputValue)\r\n            // Para mostrar primero los gifs del ultimo estado que ingresamos al input colocamos primero el inputValue, y despues el resto de categorias que ya teniamos\r\n            setCategories([inputValue, ...categories]);\r\n            // Limpiamos el inputValue/Se borra el contenido del input\r\n            setInputValue('');\r\n        }\r\n        \r\n    }\r\n\r\n    return (\r\n\r\n            // onSubmit: Al enviar el formulario se dispara la funcion de hanldeSubmit\r\n        <form onSubmit={handleSubmit}>\r\n            {/* onChange: Cada que se escriba o se elimine algo se va a disparar el evento, este evento cambia el estado de nuestro inputValue a lo que se escriba dentro del input, esto pues literalmente por cada letra que coloquemos o quitemos va a estar ejecutando esa funcion que 'cambia el estado'/'reescribe' nuestro value(contenido) de nuestro input */}\r\n            <input type=\"text\" value={inputValue} onChange={ handleInputChange }/>\r\n        </form>\r\n\r\n    )\r\n}\r\n\r\n// PropTypes\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired,\r\n    categories: PropTypes.array.isRequired\r\n\r\n};\r\n\r\n","\r\nexport const getGifs = async(category) => {\r\n\r\n    // URL Obtenida con Postman                 \r\n    //encoreURI() para escapar espacios y otras cosas para que la peticion sea correcta\r\n    const url = `http://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=GW675eA5UoLY5MPJp24XhHaoH7PD8PFf`\r\n    // Aplicamos Fetch y esto nos devuelve un arreglo .json(data)\r\n    const resp = await fetch(url);\r\n    // Nos retorna un json(objeto) el cual contiene un arreglo de objetos y otros 2 objetos, aplicamos destructuring a la data\r\n    const {data} = await resp.json();\r\n    // En una variable nueva barremos el arreglo de objetos con ayuda de .map y extraemos los 10 elementos (son 10 porque en nuestra URL obtenida con Postman colocamos que fueran 10 gifs como limite), solamente queremos el id, el titulo, y el url del objeto y aplicamos destructuring:\r\n    const gifs = data.map(({id, title, images}) => {\r\n        return {\r\n            // Va a retornar 10 objetos a nuestra constante gifs los cuales solo van a contener como id el 'img.id', es img porque lo colocamos como referencia al objeto, pero en este caso le aplicamos destructuring, por lo tanto solo colocamos que los objetos tomaran como id: el id que viene en la data del API\r\n            id: id,\r\n            title: title,\r\n            // Esto es el gif como tal, estamos extrayendo el url del gif 'medium', no tan grande de img.images, el signo de intorrogacion es por si acaso no puede retornarnos alguna imagen\r\n            url: images?.downsized_medium.url\r\n        }\r\n    })\r\n    \r\n    console.log('Gifs es tipo: ' + typeof gifs);\r\n    // Retorna 10 objetos que contienen el id, titulo y el url de la imagen, esto lo inyectamos a la propiedad de nuestro custome Hook 'images'\r\n    console.log(gifs);\r\n    return gifs;\r\n\r\n}","import React from 'react'\r\n\r\n// Aplicamos destructuring\r\nexport const GifGridItem = ({ title, url }) => {\r\n    // console.log(id, title, url);\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeInDown\">\r\n            {/* Generamos 10 cartas */}\r\n            <img src={url} alt={title}/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\nimport { GifGridItem } from './GifGridItem'\r\n\r\n\r\nexport const GifGrid = ({category}) => {\r\n    \r\n    // Desestructuramos el objeto\r\n    const {images, loading} = useFetchGifs(category);\r\n\r\n    return (\r\n        <>``\r\n            <h3 className=\"animate__animated animate__fadeInDown\">{category}</h3>\r\n            {/* Operador ternario con AND */}\r\n            <h4 className=\"animate__animated animate__flash\">{loading && 'Cargando...'}</h4>\r\n            \r\n            <div className=\"card-grid\">\r\n\r\n                { \r\n                    // Va a iterar 10 veces, nos va a generar 10 cartas, y son solo 10 veces porque el images solo contiene 10 objetos, el images => hace referenacia al objeto 'images'\r\n                    images.map( images => {\r\n                        return <GifGridItem\r\n                            key={images.id}\r\n                            // Con esto mandamos todo el objeto completo de 'images', ya en el componente de GifGridItem haremos destructuring\r\n                            { ...images }\r\n                        />\r\n                    } )\r\n                }\r\n\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n\r\n\r\n","import { useEffect, useState } from \"react\"\r\nimport { getGifs } from '../helpers/getGifs'\r\n\r\n\r\n// Todo esto vuelve a cargar porque desde el GifExpertApp se detecto un cambio en las categorias(se agrego otra), por lo tanto todo esto se vuelve a rederizar, se vuelve a hacer la peticion HTTP y se muestran los resultados en pantalla\r\nexport const useFetchGifs = (category) => {\r\n\r\n    const [state, setState] = useState({\r\n        images: [],\r\n        loading: true\r\n\r\n    });\r\n    // console.log(typeof state);\r\n    // console.log(typeof state.images);\r\n    // console.log(state);\r\n    // console.log(state.images);\r\n    // console.log(state.loading);\r\n    useEffect(() => {\r\n        // Le pasamos como argumento la categoria y nos retorna 10 objetos los cuales inyectamos en nuestro 'images' y aprovechamos a cambiar el loading a false para que se elimine el h4 que dice 'Cargando...'\r\n        getGifs(category).then(img => {\r\n            \r\n            // Esto se dispara 3 seg despues\r\n            setTimeout(() => {\r\n\r\n                setState({\r\n                    images: img,\r\n                    loading: false\r\n                })\r\n\r\n            }, 3000);    \r\n\r\n        })\r\n\r\n\r\n    }, [category])\r\n    \r\n    return state; // Retornamos: { images:[id, title, url], loading: true }\r\n\r\n}","import React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n\r\n\r\nconst GifExpertApp = () => {\r\n\r\n    // const categories = ['One Punch', 'Digimon', 'Pokemon'];\r\n    const [categories, setCategories] = useState([])\r\n\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n            {/* Comunicacion entre componentes */}\r\n            {/* Le paso como prop mi setCategories y Categories para poder 'agregar' categorias desde el componente hijo, podria obviar las 'categories'...\r\n            El nombre del prop puede ser cualquiera, pero por mantener el orden lo ponemos el mismo nombre del Hook useState \r\n            Cuando se cambia el estado de las categorias(Se agrega una nueva) todo el componente se vuelve a cargar, entonces todo vuelve a funcionar y se hacen las peticiones HTTP y todo*/}\r\n            <AddCategory setCategories={setCategories} categories={categories}/>\r\n            <hr></hr>\r\n\r\n            <ol>\r\n                { \r\n                    // Estos map's son como un for/forEach, va a iterar conforme las categorias que haya y las va a mostrar gracias al componente del GifGrid, Siempre que iteramos con .map tenemos que colocarle un key=\"\"\r\n                    categories.map( category => {\r\n                        return <GifGrid\r\n                        // El key es obligatorio y debe ser unico, no lo estamos haciendo unico ya que si buscamos 2 veces por ejemplo: 'Futbol', la key se repite y esto nos marca un warning en la consola\r\n                            key={category} \r\n                            // Le mandamos la categoria como prop\r\n                            category={category}\r\n                        />\r\n                    } )\r\n                }\r\n            </ol>\r\n        </>\r\n    );\r\n\r\n}\r\n\r\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\n\nReactDOM.render(\n\n    <GifExpertApp />,document.getElementById('root')\n  \n);\n\n"],"sourceRoot":""}